import AbstractAlgebra.Ring
import AbstractAlgebra.RingElement
import Oscar: radical_membership


module Misc
using Oscar

export add_variables, divides_power

####################################################################
#  
#  Miscellaneous routines used in the above 
#
####################################################################


function add_variables( R::T, new_vars::Vector{String} ) where{ T } # TODO: T<:Ring was not accepted for some reason. Find out why and correct that!
  if !(typeof(R)<:MPolyRing)
    error( "This method can not be implemented for non-univariate polynomial rings, yet!" )
  end
  k = base_ring(R)
  old_vars = String.( symbols(R) )
  n = length( old_vars )
  vars = vcat( old_vars, new_vars )
  S, v = PolynomialRing( k, vars )
  phi = AlgebraHomomorphism( R, S, gens(S)[1:n] )
  y = v[n+1:length(v)]
  return S, phi, y
end

####################################################################
#
# Test whether some power of the polynomial f is contained in the 
# principal ideal generated by g
#
function Oscar.radical_membership( f::T, g::T ) where{ T<:RingElem }
  if !(typeof(parent(f))<:MPolyRing)
    println( "Warning: this method does not work for univariate polynomial rings, yet!" )
  end
  R = parent(f)
  if R != parent(g) 
    error( "Polynomials do not belong to the same ring" )
  end
  S, phi, t = add_variables( R, ["t"] )
  I = ideal(S, [phi(f), one(S)-t[1]*phi(g)])
  G = groebner_basis(I,complete_reduction=true)
  if length(G)==1 && G[1] == one(S)
    return true
  end
  return false
end

##################################################################
#
# Checks whether some power of u is contained in the principal ideal 
# generated by g and returns a solution (k,a) of the equation 
#    u^k = a*g
# If no such solution exists, it returns `nothing`.
function divides_power( g::T, u::T ) where{ T<:RingElem }
  R = parent(g)
  parent(g) == parent(u) || error( "elements are not contained in the same ring" )
  # TODO: Do we want to perform a radical membership test? 
  # If yes, we can not rely on the ideal method, since 
  # this is not implemented for univariate polynomial rings.
  if !radical_membership( u, g )
    return nothing
  end

  # Check successivly higher powers of u for containment in ⟨g⟩. 
  # Once such a power is found, try to decrease it again to 
  # find the optimum.
  powers = [u]
  check = false
  a = zero(R)
  while true
    # println( "looking at the $(2^(length(powers)-1))-th power..." )
    check, a = divides( last(powers), g )
    if check
      break
    end
    push!( powers, last(powers)^2 )
  end

  # Now a power u^(2^(l-1)) is found that is divided by g with 
  # l being the length of the vector powers. We use logarithmic 
  # bisection in order to find the optimal power u^k for 
  # which this happens for the first time

  k = 2^(length(powers)-1)
  upper = pop!(powers)
  if length(powers) == 0
    # In this case u = a * g with exponent 1. No need for 
    # further bisection.
    return (1, a)
  end
  l = 2^(length(powers)-1)
  lower = pop!(powers)
  b = one(R)
  while length(powers) > 0
    # println( "looking between the $l-th power and the $k-th power..." )
    power = pop!(powers)
    middle = lower*power
    (check, b) = divides( middle, g )
    if check == true
      upper = middle
      a = b
      k -= 2^length(powers)
    else
      lower = middle
      l += 2^length(powers)
    end
  end
  return (k, a)
end

end # of module
