import AbstractAlgebra.Ring
import AbstractAlgebra.RingElement

module Misc

using Oscar

export add_variables, divides_power

####################################################################
#  
#  Miscellaneous routines used in the above 
#
####################################################################


function add_variables( R::MPolyRing, new_vars::Vector{String} )
  k = base_ring(R)
  old_vars = String.( symbols(R) )
  n = length( old_vars )
  vars = vcat( old_vars, new_vars )
  S, v = PolynomialRing( k, vars )
  phi = AlgebraHomomorphism( R, S, gens(S)[1:n] )
  y = v[n+1:length(v)]
  return S, phi, y
end

##################################################################
#
# Checks whether some power of u is contained in the principal ideal 
# generated by g and returns a solution (k,a) of the equation 
#    u^k = a*g
# If no such solution exists, it returns `nothing`.
function divides_power( g::T, u::T ) where{ T<:RingElem }
  R = parent(g)
  parent(g) == parent(u) || error( "elements are not contained in the same ring!" )
  # TODO: Do we want to perform a radical membership test? 
  # If yes, we can not rely on the ideal method, since 
  # this is not implemented for univariate polynomial rings.
  #if !radical_membership( u, ideal( parent(g), g ) )
    #return nothing
  #end

  # Check successivly higher powers of u for containment in ⟨g⟩. 
  # Once such a power is found, try to decrease it again to 
  # find the optimum.
  powers = [u]
  check = false
  a = zero(R)
  while true
    # println( "looking at the $(2^(length(powers)-1))-th power..." )
    check, a = divides( last(powers), g )
    if check
      break
    end
    push!( powers, last(powers)^2 )
  end

  # Now a power u^(2^(l-1)) is found that is divided by g with 
  # l being the length of the vector powers. We use logarithmic 
  # bisection in order to find the optimal power u^k for 
  # which this happens for the first time

  k = 2^(length(powers)-1)
  upper = pop!(powers)
  if length(powers) == 0
    # In this case u = a * g with exponent 1. No need for 
    # further bisection.
    return (1, a)
  end
  l = 2^(length(powers)-1)
  lower = pop!(powers)
  b = one(R)
  while length(powers) > 0
    # println( "looking between the $l-th power and the $k-th power..." )
    power = pop!(powers)
    middle = lower*power
    (check, b) = divides( middle, g )
    if check == true
      upper = middle
      a = b
      k -= 2^length(powers)
    else
      lower = middle
      l += 2^length(powers)
    end
  end
  return (k, a)
end

end # of module
